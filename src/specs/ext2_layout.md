# Ext2ファイルシステム - 内部レイアウト -

[The Second Extended File System: Internal Layout / Dave Poirier](http://www.nongnu.org/ext2-doc/ext2.pdf)

## 第1章 歴史的背景

## 第2章 定義

Ext2ファイルシステムは、ストレージの基本単位としてブロックを、ファイルや
システムオブジェクトを追跡する手段としてinodeを、ディスクをより管理しやすい
セクションに論理的に分割するためにブロックグループを各々使用しています。

ディレクトリはファイルを階層的に構成し、ブロックビットマップとinodeのビットマップは
割り当てられたブロックとinodeを追跡し、スーパーブロックはファイルシステムの
パラメータとその全体的な状態を定義します。

Ext2は、従来のUnixファイルシステムと多くの特性を共有しています。アクセスコントロール
リスト（ACL）、フラグメント、アンデリート、圧縮のためのスペースが仕様に含まれています。
また、Ext3やExt4のように、新機能（ジャーナル機能など）をできるだけ互換性のある方法で
追加できるようするためのバージョニング機構を備えています。

### ブロック

Ext2ファイルシステムで形成されたパーティション、ディスク、ファイル、ブロック
デバイスは、「ブロック」と呼ばれるセクタの小グループに分割されます。これらの
ブロックは、ブロックグループと呼ばれるより大きな単位にグループ化されます。

ブロックサイズは通常、ディスクのフォーマット時に決定され、パフォーマンス、最大
ファイルサイズ、最大ファイルシステムサイズに影響を与えます。一般的に実装されて
いるブロックサイズは1KiB、2KiB、4KiB、8KiBですが、スーパーブロックの規定により、
1024 * (2^31)-1という大きなブロックサイズも可能です（s_log_block_size参照）。

実装によっては、サポートするブロックサイズが制限されているアーキテクチャも
あります。例えば、DEC Alpha上のLinux 2.6の実装では、8KiBのブロックを使用して
いますが、Intel 386プロセッサ上の同じ実装では、最大4KiBのブロックサイズを
サポートしています。

表 2.1: ブロックサイズの影響

| 条件                           | 1 KiB                       | 2 KiB                    | 4 KiB                      | 8 KiB                      |
| :----------------------------- | :-------------------------- | :----------------------- | :------------------------- | :------------------------- |
| FSブロック総数                 | 2,147,483,647               | 2,147,483,647            | 2,147,483,647              | 2,147,483,647              |
| ブロック数 / ブロックグループ  | 8,192                       | 16,384                   | 32,768                     | 65,536                     |
| inode数 / ブロックグループ     | 8,192                       | 16,384                   | 32,768                     | 65,536                     |
| バイト数 / ブロックグループ    | 8,388,608 (8MiB)            | 33,554,432 (32MiB)       | 134,217,728 (128MiB)       | 536,870,912 (512MiB)       |
| ファイルシステムサイズ（実数） | 4,398,046,509,056 (4TiB)    | 8,796,093,018,112 (8TiB) | 17,592,186,036,224 (16TiB) | 35,184,372,080,640 (32TiB) |
| フィルシステムサイズ（Linux）  | 2,199,023,254,528 (2TiB) #a | 8,796,093,018,112 (8TiB) | 17,592,186,036,224 (16TiB) | 35,184,372,080,640 (32TiB) |
| ブロック数 / ファイル          | 16,843,020                  | 134,217,728              | 1,074,791,436              | 8,594,130,956              |
| ファイルサイズ（実数）         | 17,247,252,480 (16GiB)      | 274,877,906,944 (256GiB) | 2,199,023,255,552 (2TiB)   | 2,199,023,255,552 (2TiB)   |
| ファイルサイズ（linux 2.6.28） | 17,247,252,480 (16GiB)      | 274,877,906,944 (256GiB) | 2,199,023,255,552 (2TiB)   | 2,199,023,255,552 (2TiB)   |

#a: この制限は、Linux 2.4のブロックデバイスの最大サイズに由来しています。1KiBの
ブロックサイズを使用するLinux 2.6のカーネルが、2TiB以上のExt2パーティションを適切に
フォーマットしてマウントできるかどうかは不明です。

注: 2TiBのファイルサイズは、inodeのi_blocks値によって制限されます。i_blocksは、
実際に割り当てられたext2ブロックの数ではなく、512バイトのセクターの数を示しています。

### ブロックグループ

この定義は、Linux Kernel Documentationによります。

ブロックは、断片化を減らし、大量の連続したデータを読み取る際のヘッドシーク量を
最小限に抑えるために、ブロックグループにまとめられています。各ブロックグループの
情報は、スーパーブロックの直後のブロックに格納されたディスクリプターテーブルに
保持されています。各ブロックグループの先頭付近にある2つのブロックは、どのブロックと
inodeが使用されているかを示すブロック使用ビットマップとinode使用ビットマップの
ために確保されています。各ビットマップは1つのブロックに限定されているため、
ブロックグループの最大サイズはブロックの8倍になります。

各ブロックグループのビットマップに続くブロックはそのブロックグループのinode
テーブルであり、残りのブロックはデータブロックです。ブロックアロケーション
アルゴリズムは、inodeとそれが含むデータブロックを同じブロックグループに割り
当てようとします。

### ディレクトリ

この定義は、Linux Kernel Documentationに基づいており、若干の変更が加えられています。

ディレクトリはファイルシステムのオブジェクトであり、ファイルと同様にinodeを
持ちます。ディレクトリは特別にフォーマットされたファイルであり、名前とinode番号を
関連付けるレコードを含んでいます。このファイルシステムの後のリビジョンでは、
オブジェクトタイプ（ファイル、ディレクトリ、シンボリックリンク、デバイス、
FIFO、ソケット）もエンコードされるようになり、inode自体をチェックする必要が
なくなりました。

inodeを割り当てるコードは、ディレクトリが最初に作成されたブロックグループに
ディレクトリ配下のinodeを割り当てるようにするべきです。

オリジナルのExt2リビジョンでは、ディレクトリ内のファイル名の保存に単結合リストを
使用していましたが、新しいリビジョンではハッシュやバイナリツリーを使用できる
ようになりました。

また、ディレクトリが大きくなると、追加のファイルレコードを格納するために追加の
ブロックが割り当てられることに注意してください。ファイル名が削除されても、
これらの追加ブロックを解放しない実装もあります。

### inode

この定義は、Linux Kernel Documentationに基づいており、若干の変更が加えられています。

inode（インデックスノード）は、ext2ファイルシステムの基本概念です。ファイル
システムの各オブジェクトはinodeで表されます。inode構造体には、オブジェクトに
保持されているデータを含むファイルシステムブロックへのポインタと、名前を除く
オブジェクトに関するすべてのメタデータが含まれています。オブジェクトのメタデータ
には、パーミッション、オーナー、グループ、フラグ、サイズ、使用ブロック数、
アクセス時間、変更時間、修正時間、削除時間、リンク数、フラグメント、バージョン
（NFSの場合）、拡張属性（EA）やアクセスコントロールリスト（ACL）などがあります。

inode構造体には、現在使用されていないいくつかの予約フィールドとオーバーロード
されているいくつかのフィールドがあります。1つのフィールドは、inodeがディレクトリの
場合はディレクトリACLのために、inodeが通常のファイルの場合はファイルサイズの
上位32ビットのために予約されています（2GB以上のファイルサイズを許可します）。
translatorフィールドは、Linuxでは使用されていませんが、HURDでは、このオブジェクトを
解釈するためのプログラムのinodeを参照するために使用されています。残りの予約
フィールドのほとんどは、LinuxでもHURDでもownerとgroupフィールドを大きくするために
使われています。HURDはmodeフィールドも大きいので、残りのフィールドの1つを使って
余分なビットを格納しています。

inodeには、ファイルのデータを格納する最初の12ブロックへのポインタがあります。さらに
間接ブロックへのポインタ（次のブロック群へのポインタを含む）、2重間接ブロックへの
ポインタ（間接ブロックへのポインタを含む）、3重間接ブロックへのポインタ（2重
間接ブロックへのポインタを含む）があります。

ファイルシステム固有の動作フラグもいくつか保存されており、ファイルごとに特定の
ファイルシステムの動作を可能にします。安全な削除、アンデリート可能、圧縮、同期更新、
不変性、追記のみ、ダンプ可能、ノータイム、インデックス付きディレクトリ、データ
ジャーナリングなどのフラグがあります。

ジャーナリングのようなファイルシステム固有の動作フラグの多くは、Ext3やExt4などの
新しいファイルシステムで実装されていますが、その他のいくつかはまだ開発中です。

すべてのinodeはinodeテーブルに格納され、ブロックグループごとに1つのinodeテーブルが
あります。

### スーパーブロック

この定義は、Linux Kernel Documentationに基づいており、若干の変更が加えられています。

スーパーブロックには、ファイルシステムの構成に関するすべての情報が含まれています。
スーパーブロックの情報には、ファイルシステム内のinodeとブロックの総数と空き容量、
各ブロックグループ内のinodeとブロックの数、ファイルシステムがマウントされた時期
（およびクリーンにアンマウントされたかどうか）、変更された時期、ファイルシステムの
バージョン、どのOSが作成したかなどのフィールドが含まれています。

スーパーブロックのプライマリコピーは、デバイスの先頭から1024バイトのオフセットに
格納されており、ファイルシステムのマウントには欠かせません。非常に重要なので、
スーパーブロックのバックアップコピーはファイルシステムのすべてのブロックグループに
格納されています。

ext2の最初のバージョン（リビジョン0）では、すべてのブロックグループの先頭に
コピーを保存し、グループディスクリプタブロックのバックアップも保存しています。
これは大規模なファイルシステムではかなりの容量を消費するため、以降のリビジョンでは
オプションで特定のグループにのみバックアップを置くことで、バックアップコピーの
数を減らすことができます（これがsparse superblock機能です）。ここでは、0、1、
および3、5、7の累乗のグループが選択されています。

リビジョン1以降のファイルシステムでは、ボリューム名、固有の識別番号、inodeサイズ、
ファイルシステムのオプション機能の設定情報を保存するスペースなど、追加の
フィールドも保存されます。

スーパーブロックのすべてのフィールドは（他のすべてのext2構造と同様に）
リトルエンディアン形式でディスクに保存されるため、ファイルシステムはどのマシンで
作成されたかを知らなくても、マシン間で移植可能です。

### シンボリックリンク

この定義はWikipedia.orgからの引用であり、若干の変更が加えられています。

シンボリックリンク（シムリンク、ソフトリンク）とは、他のファイルやディレクトリへの
参照を絶対パスまたは相対パスの形で含み、パス名解決に影響を与える特別なタイプの
ファイルです。

シンボリックリンクは、ほとんどの操作において透過的に動作します。シンボリック
リンクで名付けられたファイルを読み書きするプログラムは、対象となるファイルを
直接操作しているかのように動作します。ただし、シンボリックリンクを特別に扱う
必要のあるプログラム（バックアップユーティリティなど）は、シンボリックリンクを
直接識別して操作することができます。

シンボリックリンクには、他のファイルやディレクトリへのパスとしてOSが解釈して
従うテキスト文字列が含まれているだけです。それ自体がファイルであり、ターゲットから
独立して存在することができます。シンボリックリンクはinodeのリンクカウントには
影響しません。シンボリックリンクが削除されても、そのターゲットは影響を受けません。
ターゲットが移動、名前変更、または削除された場合、そのターゲットを指していた
シンボリックリンクは存在し続けますが、現在は存在しないファイルを指していることに
なります。存在しないファイルを指しているシンボリックリンクは、「孤児」や
「ダングリング」と呼ばれることがあります。

シンボリックリンクはinodeを持つファイルシステムオブジェクトでもあります。
60バイト以下のシンボリックリンクでは、データはinode自体に格納され、通常は
データブロックへのポインタを格納するフィールドが使用されます。これは、シンボリック
リンクのために完全なブロックを割り当てることを避けることができ、またほとんどの
シンボリックリンクは60文字以下の長さなので、価値のある最適化です。

シンボリックリンクは、他のパーティションやファイルシステムのファイルや
ディレクトリを指すこともできます。

## 第3章 ディスク構成

Ext2ファイルシステムは、ボリュームの先頭からバイトオフセット1024に位置する
スーパーブロックで始まります。これは、1KiBブロックフォーマットのボリュームでは
ブロック1、それ以上のブロックサイズではブロック0にあります。スーパーブロックの
サイズは、ブロックサイズに関係なく一定であることに注意してください。

スーパーブロックの次のブロックには、ブロックグループディスクリプタテーブルがあり、
ボリュームがどのようにブロックグループに分割されているか、各ブロックグループの
inodeビットマップ、ブロックビットマップ、inodeテーブルがどこにあるかの概要を
示しています。

Ext2のリビジョン0では、各ブロックグループは、スーパーブロックのコピー、ブロック
グループディスクリプタテーブルのコピー、ブロックビットマップ、inodeビットマップ、
inodeテーブル、およびデータブロックで構成されています。

リビジョン1ではExt2のスパーススーパーブロック機能の導入により、特定のブロック
グループのみがスーパーブロックとブロックグループディスクリプターテーブルの
コピーを含むようになりました。すべてのブロックグループには、ブロックビットマップ、
inodeビットマップ、inodeテーブル、およびデータブロックが含まれます。スーパー
ブロックのコピーは、ブロックグループ0、1、および3、5、7の累乗に配置する
ことができます。

ブロックビットマップとinodeビットマップは、ブロックグループごとにそれぞれ1ブロックに
制限されているため、ブロックグループごとの総ブロック数は制限されます(詳細は
「ブロックサイズの影響」の表を参照してください）。

また、各データブロックは、さらに「フラグメント」に分割されることもあります。
Linux 2.6.28の時点では、フラグメントのサポートはまだカーネルに実装されていません。
したがって、互換性を維持するために、フラグメントサイズがブロックサイズと同じに
なるようにすることが推奨されます。

表 3.1: 1 KiBブロックのフロッピーディスクレイアウト例

![表3.1](screens/ext2_table_3.1.png)

不思議なことに、ブロック0は常にディスクやパーティションの最初のセクターを指し、
ブートレコードがあればそれが格納されます。

スーパーブロックは、ディスクやパーティションの先頭からバイトオフセット1024の
位置にあります。1KiBブロックサイズのフォーマットされたファイルシステムでは、
これはブロック1ですが、より大きなブロックサイズのファイルシステムでは、常に
ブロック0（ブロック0の1024バイト目）になります。

ここでは、1KiBブロックを使用した20MBのext2ファイルシステムの構成を示しています。

表 3.2: 20MBのパーティションレイアウト例

![表3.2-1](screens/ext2_table_3.2_1.png)
![表3.2-2](screens/ext2_table_3.2_2.png)

ディスク上のレイアウトは、いくつかの基本情報（ブロックサイズ、グループごとの
ブロック、グループごとのinode）を知っている限り、非常に予測しやすいものです。
これらの情報はすべて、スーパーブロック構造の中にあるか、そこから計算することが
できます。

しかし、イメージが制御されたパラメータで作成されていない限り、ディスク上の様々な
構造（スーパーブロックを除く）の位置を想定してはいけません。必ずスーパーブロックを
最初に読み込むようにしてください。

ブロックサイズが1KiBのファイルシステムでは、ブロック0がブロックグループ0に含まれて
いないことに注目してください。この理由は、ブロックグループ0は常にスーパーブロックを
含むブロックから始まるからです。したがって、1KiBブロックシステムではブロック
グループ0はブロック1から始まりますが、それ以上のブロックサイズではブロック0から
始まります。詳細は、s_first_data_blockスーパーブロックのエントリを参照してください。

### スーパーブロック

スーパーブロックは、Ext2およびそれ以降のバージョン（Ext3、Ext4）でフォーマット
されたファイル、ブロックデバイス、またはパーティションの先頭から、常にバイト
オフセット1024に位置しています。

スーパーブロックの構造は、Ext2からExt3、Ext4までほとんど変わらず、いくつかの
マイナーな変更があるだけです。

表 3.3: スーバーブロック構造体

![表3.3-1](screens/ext2_table_3.3_1.png)
![表3.3-2](screens/ext2_table_3.3_2.png)
![表3.3-3](screens/ext2_table_3.3_3.png)
![表3.3-4](screens/ext2_table_3.3_4.png)

<dl class="dl-inline">
<dt>s_inodes_count</dt>
<dd>
ファイルシステムにおける使用済と未使用を合わせたinodeの総数を示す32ビットの値。この値は
(s_inodes_per_group * ブロックグループ数)以下で、かつ、各ブロックグループで定義されているinodeの
合計と等しくなければならない。
</dd>
</dl>

### ブロックグループ記述子テーブル

ブロックグループ記述子テーブルはブロックグループ記述子の配列であり、すべてのブロックグループの
パラメータを定義するために使用されます。これは、inodeビットマップとinodeテーブル、ブロックビット
マップの位置、空きブロックと空きinodeの数、その他の有用な情報を提供します。

ブロックグループ記述子テーブルは、スーパーブロックに続く最初のブロックから始まります。これは
1KiBブロックのファイルシステムでは3番目のブロック、2KiB以上のブロックのファイルシステムでは
2番目のブロックになります。ブロックグループ記述子テーブルのシャドウコピーはスーパーブロックの
コピーと同じように保存される。

定義されているブロックグループの数によってはこのテーブルは複数ブロックの領域を必要とすることが
あります。疑わしい場合は常にスーパーブロックを参照してください。

ブロックグループ記述子のレイアウトは以下の通りです。

表3.12: ブロックグループ記述子構造体

![表3.12](screens/ext2_table_3.12.png)

ファイルシステムに存在する各ブロックグループに対してブロックグループ記述子が作成されます。
各記述子はファイルシステムの一つのブロックグループを表すものであり、その情報は記述している
グループにのみ適用されるものです。すべてのブロックグループ記述子テーブルにはすべてのブロック
グループに関するすべての情報が含まれています。

**注意**: すべての"ブロックID"は絶対値です。

### ブロックビットマップ

小さなファイルシステムでは通常「ブロックビットマップ」は各ブロックグループの最初のブロック
（スーパーブロックのバックアップがある場合は2番目のブロック）に配置されます。その正式な位置は
所属するグループ記述子の`bg_block_bitmap`を読むことで確認できます。

各ビットはそのブロックグループ内のブロックの現在の状態を表し、`1`は「使用済み」、
`0`は「空き/使用可能」を意味します。このブロックグループの最初のブロックは、バイト0のビット0で
表され、2番目のブロックは、バイト0のビット1で表されます。8番目のブロックはバイト0のビット7
（最上位ビット）、9番目のブロックはバイト1 のビット0（最下位ビット）で表されます。

### INodeビットマップ

「Inodeビットマップ」は「ブロックビットマップ」と同じように働きますが、各ビットがブロックではなく
「Inodeテーブル」のinodeを表していることが違います。inode番号は0ではなく1から始まるので、最初の
ブロックグループのinodeビットマップの最初のビットはinode番号`1`を表します。

グループごとに1つのinodeビットマップがあり、その位置は所属するグループ記述子の"bg_inode_bitmap"を
読むことで確認できます。

inodeテーブルが作成される時に予約済みのすべてのinodeは使用済みとマークされます。これはリビジョン0では
最初の11個のinodeです。

### INodeテーブル

inodeテーブルは、すべてのディレクトリ、通常ファイル、シンボリックリンク、特殊ファイルを追跡する
ために使用されます。それらの位置、サイズ、タイプ、アクセス権はすべてinodeに格納されます。ファイル名は
inode自体には格納されません。名前はディレクトリファイルに名前が格納されます。

inodeテーブルはブロックグループごとに1つあり、その場所は所属するグループ記述子の"bg_inode_table"を
読むことで知ることができます。1つのテーブルには"s_inodes_per_group"個のinodeが格納されます。

各inodeは、システム上にある1つの物理ファイルに関する情報を含みます。ファイルには、ディレクトリ、
ソケット、バッファ、キャラクタデバイス、ブロックデバイス、シンボリックリンク、通常ファイルがあります。
したがって、inodeは、ディスク上の位置、サイズ、所有者を記述しているある実体に関する情報ブロックと
見なすことができます。inodeは次のようなものです。

表3.13: INode構造体
![表3.13](screens/ext2_table_3.13.png)

inodeテーブルの最初の数エントリは予約されています。リビジョン0では11エントリが予約されていますが、
リビジョン1（EXT2_DYNAMIC_REV）以降では予約済みのinodeエントリ数はスーパーブロック構造体の
"s_first_ino"で指定されます。以下は、既知の予約済みinodeエントリのリストです。

表3.14: 定義済み予約INode
![表3.14_1](screens/ext2_table_3.14_1.png)
![表3.14_3](screens/ext2_table_3.14_2.png)

### INodeを配置する

Inodeはすべて数字順に並べられます。「inode番号」はinodeテーブルにおけるinode構造体の
インデックスです。

inodeテーブルのサイズはフォーマット時に固定され、最大数のエントリを保持するように
構築されます。作成されるエントリが膨大なためテーブルはかなり大きくなるのですべての
ブロックグループに均等に分割されます（詳細は第3章「ディスクの構成」を参照）。

スーパーブロック構造のs_inodes_per_groupフィールドはグループごとに何個のinodeが定義されて
いるかを教えてくれます。

inode 1がinodeテーブルで定義されている最初のinodeであることがわかっているので次の式を
使用することができます。

ブロックグループ = (inode - 1) / s_inodes_per_group

ブロックが特定されたらローカルinodeテーブルのローカルinodeインデックスをは次の式で特定
することができます。

ローカルinodeインデックス = (inode - 1) % s_inodes_per_group

以下は実装をテストするために使用できるいくつかのサンプル値です。

表3.20: INodeの計算例
![表3.20](screens/ext2_table_3.20.png)


もうすでにご存知のようにインデックス0は最初のエントリを意味します。1ではなく0を使用する理由は
メモリやディスク上の位置の最終的なバイトオフセットを見つけるために構造体のサイズをより簡単に
掛けることができるからです。

## 第4章 ディレクトリ構造

ディレクトリはファイルを階層的に整理するために使用されます。ディレクトリには他のディレクトリや
通常ファイル、特殊ファイルなどを格納することができます。

ディレクトリはデータブロックとして格納され、inodeで参照されます。ディレクトリはinode構造体の
i_modeフィールドに格納されているファイルタイプEXT2_S_IFDIRにより識別されます。

Inodeテーブルの2番目のエントリは、EXT2_ROOT_INO定数で定義されているルートディレクトリの
データを指し示すinodeです。

リビジョン0ではディレクトリはリンクトリストにしか格納できませんでした。リビジョン1以降では
索引化ディレクトリが導入されました。索引化ディレクトリはリンクトリストと後方互換性があります。
これはハッシュインデックスをスキップする空のディレクトリエントリレコードを挿入することで
実現しています。

### リンクトリストディレクトリ

ディレクトリファイルはディレクトリエントリ構造体のリンクトリストです。各構造体はエントリの名前、
このエントリーのデータに関連するinode、およびディレクトリファイル内の次のエントリまでの距離を
含んでいます。

リビジョン0では、エントリのタイプ（ファイル、ディレクトリ、特殊ファイルなど）はファイルのinodeで
調べる必要があります。リビジョン0.5以降では、ファイルタイプもディレクトリエントリ構造体にに含まれ
るようになりました。

表4.1: リンクトディレクトリエントリ構造体
![表4.1](screens/ext2_table_4.1.png)

a) Ext2のリビジョン0では、16 ビットのname_lenを使用していました。多くの実装ではファイル名を
最大255文字に制限していたため、この値を8ビットに切り詰め、上位8ビットをfile_typeとしてリサイクル
しました。

b) リビジョン0では使用不可。このフィールドは16bitのname_lenフィールドの一部でした。


#### file_type

表4.2: 定義済みinodeファイルタイプ値
![表4.2](screens/ext2_table_4.2.png)

### ディレクトリ例

以下は私のシステムのあるユーザのホームディレクトリの例です。

```
$ ls -la -
.
..
.bash_profile
.bashrc
mbox
public_html
tmp
```

これはストレージデバイス上では次のようなデータ表現になります。

表4.3: リンクトディレクトリデータレイアウト例
![表4.3-1](screens/ext2_table_4.3_1.png)
![表4.3-2](screens/ext2_table_4.3_2.png)
![表4.3-3](screens/ext2_table_4.3_3.png)

### 索引化ディレクトリフォーマット

#### 索引化ディレクトリのルート

#### 索引化ディレクトリエントリ

## 第5章 ファイル属性

ほとんどのファイル属性（ディレクトリ、シンボリックリンク、デバイス属性も）は
ファイルに関連付けられたinodeに格納されます。他のいくつかの属性は拡張属性としてのみ
利用可能です
