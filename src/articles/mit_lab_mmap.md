

# [Lab: mmap](https://pdos.csail.mit.edu/6.828/2019/labs/mmap.html)

システムコール`mmap`と`munmap`を使用すると、UNIXプログラムが自分のアドレス
空間を詳細に制御することができます。mmapとmunmapは、プロセス間でメモリを
共有したり、ファイルをプロセスのアドレス空間にマッピングしたり、講義で
説明したガーベージコレクションアルゴリズムのようなユーザレベルのページ
フォールトスキームの一部として使用することができます。このラボでは、
メモリマップドファイルに焦点を当てながら、xv6にmmapとmunmapを追加します。


マニュアルページ（`man 2 mmap`）を見ると、mmapの宣言は次のようになっています。

```
void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
```

mmapはさまざまな方法で呼び出すことができますが、このラボではファイルの
メモリマッピングに関連する機能のサブセットのみを必要とします。mmapはその
アドレスを返しますが、失敗した場合は 0xffffffffff を返します。`prot`は
マップドメモリが読み取り可能か、書き込み可能か、または実行可能かを示します。
`flags`は、マップドメモリに対する変更をファイルに書き戻す必要があることを
意味する`MAP_SHARED`と書き戻す必要がないことを意味する`MAP_PRIVATE`の
いずれかです。`fd`はマップドファイルのオープンファイルディスクリプタです。
`offset`は`0`であると仮定して構いません(マッピングドファイルの開始点です)。

同じMAP_SHAREDファイルをマッピングするプロセスが、物理ページを共有して
いなくても**構いません**。

`munmap(addr, length)`は指定されたアドレス範囲のmmapマッピングを削除します。
プロセスがメモリを変更し、それがMAP_SHAREDにマップされている場合は、まず
その変更をファイルに書き込む必要があります。`munmap`システムコールはmmap
された領域の一部しかカバーしていない場合もあるかもしれませんが、最初か最後か、
あるいは領域全体のマッピングを解除すると仮定することができます（ただし、
領域の真ん中に穴を開けることはできません）。

より一般的にはmmaptestテストプログラムが動作するのに十分なmmapとmunmapの
機能を実装する必要があります。mmaptestが仕様していないmmapの機能は実装する
必要はありません。

完了すると、次のような出力が表示されるはずです。

```
$ mmaptest
mmap_test starting
mmap_test OK
fork_test starting
fork_test OK
mmaptest: all tests succeeded
$
$ usertests
usertests starting
test reparent2: OK
...
test bigdir: OK
ALL TESTS PASSED
$
```

いくつかのヒントを紹介します。

- まず、`user/mmaptest.c`をコンパイルするために、システムコールmmapとmunmap
  関連するフラグ(`PROT_READ`など)を追加することから始めます。この段階では、
  mmapとmunmapはエラーを返すだけです。mmaptestを実行すると最初のmmap呼び
  出しで失敗します。
- ページテーブルは、ページフォールトに対応して遅延的に埋めます。つまり、
  mmapは物理メモリの割り当てやファイルの読み取りを行うべきではありません。
  代わりに、遅延ページ割り当てを扱ったラボのようにusertrap内の（または
  usertrapによって呼び出される）ページフォルト処理コードで行います。遅延
  させる理由は、大きなファイルのmmapが高速であることと、物理メモリよりも
  大きなファイルのmmapが可能であることを保証するためです。
- mmapが各プロセスに対して何をマッピングしたかを記録します。第15講で説明した
  VMA（仮想メモリ領域）に相当する構造体を定義し、mmapが作成した仮想メモリ
  範囲のアドレス、長さ、パーミッション、ファイルなどを記録します。xv6カーネル
  はカーネル内にメモリアロケータを持たないので、VMAの固定サイズの配列を
  宣言し、必要に応じてその配列からアロケートすればOKです。
- mmapを実装します。プロセスのアドレス空間でファイルをマッピングする未使用
  領域を見つけ、プロセスのマッピング領域のテーブルにVMAを追加します。VMAには
  マッピングされるファイルの構造体ファイルへのポインタを含める必要があります。
  mmapはファイルが閉じられたときに構造体が消えてしまわないようにファイルの
  参照カウントを増やす必要があります (ヒント: filedupを参照)。mmaptestを
  実行します。最初のmmapは成功するはずですが、mmapされたメモリへの最初の
  アクセスはページフォルトを引き起こし、mmaptestを終了させます。
- mmapされた領域でページフォルトを起こすコードを追加して、物理メモリの
  ページを割り当て、そのページに関連ファイルの4096バイトを読み込んで、
  ユーザーアドレス空間にマッピングします。`readi`でファイルを読み込みます。
  `readi`はファイルを読み込むためのオフセット引数を取ります（ただし、`readi`
  に渡された`inode`をロック／アンロックする必要があります）。ページの
  パーミッションを正しく設定することを忘れないでください。mmaptestを実行
  します。最初のmunmapにたどり着くはずです。
- `munmap`を実装します。アドレス範囲のVMAを見つけて、指定されたページの
  マッピングを解除します(ヒント: uvmunmapを使う)。munmapが以前のmmapの
  すべてのページを削除した場合、対応する`struct file`の参照カウントを
  デクリメントする必要があります。マップされていないページが変更されており、
  ファイルがMAP_SHAREDマップドの場合はそのページをファイルに下記戻します。
  `filewrite`を参考にしてください。
- 理想的な実装は、プログラムが実際に変更したMAP_SHAREDページのみを書き戻す
  ことです。RISC-V PTEのダーティビット(D)は、ページが書き込まれたかどうかを
  示します。しかし、mmaptestはダーティでないページが書き戻されていないか
  どうかはチェックしませんので、Dビットを見ずにページを書き戻すことができます。
- munmapが呼び出されたかのようにプロセスのマッピングド領域のマッピングを
  解除するように`exit`を変更します。mmaptestを実行します。mmap_testは通過
  するはずですが、おそらくfork_testは通過しないでしょう。
- 子が親と同じマップド領域を持つように、forkを修正します。VMAの構造体
  ファイルの参照カウントをインクリメントすることを忘れないでください。
  子のページフォルトハンドラでは、親とページを共有するのではなく、新しい
  物理ページを割り当てても構いません。後者の方がクールですが、より多くの
  実装作業が必要になります。mmaptestを実行します。mmap_testとfork_testの
  両方に合格するはずです。

usertestを実行して、依然としてすべてが動作することを確認します。

## オプションの課題

- 2つのプロセスが同じファイルをmmapした場合 (fork_test の場合)、それらの
  物理ページを共有します。物理ページの参照カウントが必要になります。
- このソリューションでは、データがバッファキャッシュ内のカーネルメモリに
  あるにもかかわらず、mmapドファイルからページを読み取るたびに新しい物理
  ページを割り当てていると思われます。新しいページを割り当てるのではなく、
  その物理メモリを使用するように実装を変更してください。そのためには
  ファイルブロックのサイズをページと同じにする必要があります（BSIZEを4096に
  設定）。mmap化されたブロックをバッファキャッシュに固定する必要があります。
  参照カウントを気にする必要があります。
- 遅延アロケーションの実装と、mmapドファイルの実装の間の冗長性を取り除きます。
  (ヒント: 遅延割り当て領域のためにVMAを作成します。)
- オンデマンドでページングされた実行ファイルを得るために、バイナリの異なる
  セクションにVMAを使用するようにexecを変更します。これにより、execがファイル
  システムからデータを読み込む必要がなくなるため、プログラムの起動が速く
  なります。
- ページアウトとページインの実装：物理メモリが不足したときに、カーネルが
  プロセスの一部をディスクに移動させます。そして、プロセスが参照するときに、ページアウトされたメモリをページインします。
