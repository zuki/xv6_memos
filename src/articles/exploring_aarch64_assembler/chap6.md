# [AArch64アセンブラ研究: 第6章](https://thinkingeek.com/2016/11/27/exploring-aarch64-assembler-chapter-6/)

これまでに計算とメモリアクセスの方法を知りました。今日はプログラムの
制御フローを変更する方法を学びます。

## 暗黙のシーケンス

ほとんどの人はこれまでの章で見てきたような一連の命令は順番に実行される
ものと思っているでしょう。これは非常に基本的なことですので暗黙の
シーケンスと呼ぶことができます。すなわち、ある命令が実行されたら次の
命令が実行されるということです。これは当たり前のように思えます。

しかし、この暗黙のシーケンスを何か別のものに変えたいとしたらどうで
しょうか。命令のサブセットを選択的に実行することができるとしたらどうで
しょうか。さらに言えば、ある条件に応じて命令のサブセットを実行することが
できたらどうでしょうか。

## プログラムの置き場所

プログラムはメモリに格納されます。これはきわめて当たり前のことのように
思えます。しかし、実際はそうではありません。非常に特殊な処理を行う
デジタル回路は比較的簡単に作ることができます。その「プログラム」は
メモリの中にはなく、直接、回路にコード化されています。しかし、このような
回路がある一方で、現在では、命令としてコード化されたプログラムを実行
できる非常に高度な回路であるCPUを使用することができます。

プログラムがメモリの中にあり、その中核が命令の束であるということは
命令がアドレス可能である（メモリにあればアドレスを持つ）ことを意味します。
機能的な観点からは、CPUは任意のある時点において1つの命令しか実行しない
ことを考えると、どの命令が実行中であるかを知ることは意味のあることで
しょう。命令自体は、すなわち、その命令に関連する特定のバイナリコードは
あまり有用ではありませんが、そのアドレスは有用です。そこで、現在の命令の
アドレスをCPUのどこかに保存しておきたいと思うでしょう。そして、それが
実際に行われていることなのです。

## プログラムカウンタ

現在の命令を記録しているメモリをプログラムカウンタと呼びます。AArch64では
プログラムカウンタはpc（Program Counterの意）と呼ばれるレジスタに格納
されています。これは64ビットのレジスタで、現在の命令のアドレスが格納
されています。

pcはCPUに実行すべき命令がどれかを伝えます。CPUはメモリにアクセスして
pcが伝えたアドレスにある4バイトを要求します。この4バイトが命令です。
AArch64では命令は32ビットでエンコードされることを思い出してください。
そして、その命令が実行されます。命令の実行が終了するとPCは4バイトだけ
増分されます。これが暗黙のシーケンシングの仕組みです。これだけです。

しかし、`pc ← pc ＋ 4`とするのではなく、何らかの方法で命令の終了時に
pcを他の値にすることができるとしたらどうだろうかと思うかもしれません。
CPUは次の命令ではなく他の命令を実行できるでしょうか。答えはイエスです。
ただし、AArch64で直接pcに書き込むことはできません。しかし、分岐を使えば
可能です。

## 分岐

分岐はPCを変更することができる命令です。そうすることでプログラムの暗黙の
シーケンスを変更することができます。

分岐には無条件分岐と条件分岐の2種類があります。無条件分岐は常にPCを
ある値に設定し、条件分岐はある条件が成立した時だけ設定します。ある分岐が
PCを設定した時、その分岐が行われたと言います。pcにセットされるアドレスを
分岐席と呼びます。分岐が行われない場合は暗黙のシーケンスが適用されます。

### 分岐先

分岐先はアドレスです。アセンブラにおけるアドレスはほとんどの場合、
シンボリックラベルを使って表現されます。そのため、分岐には少なく
とも1つのオペランドがあり、それが分岐先です。アドレスは命令の中に
組み込まれているため、使用できるラベルには制限があります。

## 無条件分岐

無条件分岐は`b`（branch）命令で表現されます。分岐先は27ビット、すなわち、
±128MiBのオフセットとして符号化されます。このオフセットは、アセンブラ
ツールにより計算されてpcに加算されます。

次のプログラムは、たとえエラー条件を4にする命令があっても、エラー条件を
3にします。分岐は単に2番目の`mov`の実行をスキップします。

```
/* branch */
.text
.global main
main:
    mov w0, #3      // w0 ← 3
    j jump          // jumpラベルに分岐
    mov w0, #4      // w0 ← 4
jump:
    ret             // 関数の終了
```

ラベルは独立した行に書くことにしています（上のmain:とjump:を見て
ください）。こうすると少し読みやすいと思います。また、ラベル後の
命令はインデントすることにします(retを見てください)。

このプログラムを実行するとエラーコードは3になります。

```sh
$ ./branch ; echo $?
3
```

質問が出る前に説明しますが、はい、自分自身にジャンプすることにより
けっして終わらないプログラムを作ることができます。次のプログラムは
ハングします（`Ctrl-C`で終了します）。

```
/* neverend.s */
.text
.global main
main:
    noprogress:         // `main`と`nopgress`は同じアドレスへの
                        // 2つの異なるラベルであることに注意。
                        // `b main`としてもハングします
        b noprogress
    ret                 // けっしてリターンすることはない!
```

一見すると無条件分岐はあまり意味がないように思えます。有用性はあるの
ですが、それを理解するためにはまだその詳細が不足しています。次の章で
もう一つの無条件分岐命令`bl`について見ていきます。その命令はもっと
興味深いものです。約束します。
